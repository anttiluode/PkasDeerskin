<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Deerskin-PKAS Live Demo</title>
<style>
  :root {
    --bg: #0d0d1a; --panel: #151528; --border: #2a2a4a;
    --accent: #00ffdd; --accent2: #e879f9; --warn: #ff6b6b;
    --text: #e0e0e0; --muted: #888;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: var(--bg); color: var(--text); font-family: 'Consolas', monospace;
         min-height: 100vh; overflow-x: hidden; }

  header { padding: 20px 40px; border-bottom: 1px solid var(--border); }
  header h1 { color: var(--accent); font-size: 1.4rem; letter-spacing: 2px; }
  header p  { color: var(--muted); font-size: 0.8rem; margin-top: 4px; }

  .grid { display: grid; grid-template-columns: 1fr 1fr 1fr;
          gap: 20px; padding: 20px 40px; }
  .panel { background: var(--panel); border: 1px solid var(--border);
           border-radius: 8px; padding: 16px; }
  .panel h3 { color: var(--accent); font-size: 0.85rem; letter-spacing: 1px;
              margin-bottom: 12px; text-transform: uppercase; }
  canvas { display: block; width: 100%; border-radius: 4px; }

  .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 12px; }
  .stat  { background: #0d0d1a; border-radius: 4px; padding: 8px 10px; }
  .stat label { color: var(--muted); font-size: 0.7rem; display: block; }
  .stat span  { color: var(--accent); font-size: 1.1rem; font-weight: bold; }

  .controls { padding: 0 40px 20px; display: flex; gap: 12px; align-items: center;
              flex-wrap: wrap; }
  button { background: var(--panel); color: var(--accent); border: 1px solid var(--accent);
           padding: 8px 20px; border-radius: 4px; cursor: pointer; font-family: inherit;
           font-size: 0.85rem; transition: background 0.2s; }
  button:hover { background: var(--accent); color: var(--bg); }
  button.warn  { border-color: var(--warn); color: var(--warn); }
  button.warn:hover { background: var(--warn); color: var(--bg); }

  label.slider { color: var(--muted); font-size: 0.8rem; display: flex;
                 align-items: center; gap: 10px; }
  input[type=range] { accent-color: var(--accent); width: 100px; }

  .log { padding: 0 40px 30px; }
  .log-box { background: var(--panel); border: 1px solid var(--border); border-radius: 4px;
             padding: 12px; font-size: 0.75rem; color: var(--muted); height: 80px;
             overflow-y: auto; }
  .log-box .good { color: var(--accent); }
  .log-box .bad  { color: var(--warn); }

  .theory { padding: 0 40px 40px; display: grid; grid-template-columns: 1fr 1fr;
            gap: 20px; }
  .theory .panel { font-size: 0.8rem; line-height: 1.7; color: #aaa; }
  .theory .panel strong { color: var(--text); }
  .theory .panel code   { color: var(--accent2); font-size: 0.75rem; }
</style>
</head>
<body>

<header>
  <h1>‚öô DEERSKIN-PKAS  ‚Äî  Live Visualisation</h1>
  <p>Geometric Prior replaces Temperature Schedule  ¬∑  Calcium trails replace random restarts  ¬∑  Viscous Melt replaces cooling</p>
</header>

<div class="controls">
  <button id="btnStart">‚ñ∂ Start</button>
  <button id="btnReset">‚Ü∫ New Graph</button>
  <button id="btnCollapse" class="warn">üí• Inject Collapse</button>
  <label class="slider">Nodes: <input type="range" id="slNodes" min="10" max="40" value="20">
    <span id="lblNodes">20</span></label>
  <label class="slider">Melt Rate: <input type="range" id="slMelt" min="1" max="30" value="3">
    <span id="lblMelt">0.003</span></label>
  <label class="slider">Speed: <input type="range" id="slSpeed" min="1" max="20" value="5">
    <span id="lblSpeed">5</span></label>
</div>

<div class="grid">
  <!-- Panel 1: Moir√© field -->
  <div class="panel">
    <h3>‚¨° Geometric Prior Field</h3>
    <canvas id="cvMoire" width="280" height="280"></canvas>
    <div class="stats">
      <div class="stat"><label>Stress</label><span id="stStress">0.00</span></div>
      <div class="stat"><label>Prior Œ∏</label><span id="stTheta">0.00</span></div>
      <div class="stat"><label>Melt Rate</label><span id="stMelt">0.003</span></div>
      <div class="stat"><label>Scars</label><span id="stScars">0</span></div>
    </div>
  </div>

  <!-- Panel 2: Graph -->
  <div class="panel">
    <h3>‚óé Graph State</h3>
    <canvas id="cvGraph" width="280" height="280"></canvas>
    <div class="stats">
      <div class="stat"><label>Cut Value</label><span id="stCut">0</span></div>
      <div class="stat"><label>Best Cut</label><span id="stBest">0</span></div>
      <div class="stat"><label>Edges</label><span id="stEdges">0</span></div>
      <div class="stat"><label>Cut %</label><span id="stPct">0%</span></div>
    </div>
  </div>

  <!-- Panel 3: Convergence -->
  <div class="panel">
    <h3>‚àø Convergence</h3>
    <canvas id="cvConv" width="280" height="280"></canvas>
    <div class="stats">
      <div class="stat"><label>Iteration</label><span id="stIter">0</span></div>
      <div class="stat"><label>Calcium Max</label><span id="stCa">0.00</span></div>
      <div class="stat"><label>Rescues</label><span id="stRescues">0</span></div>
      <div class="stat"><label>Status</label><span id="stStatus">Idle</span></div>
    </div>
  </div>
</div>

<div class="log">
  <div class="log-box" id="logBox">Waiting to start‚Ä¶</div>
</div>

<div class="theory">
  <div class="panel">
    <h3 style="color:var(--accent2);margin-bottom:10px">WHY P-KAS COLLAPSED</h3>
    P-KAS had Kuramoto phases, calcium memory, and a W-matrix ‚Äî
    but <strong>no geometric prior</strong>. It explored symmetrically.
    Around iteration ~1000, phase synchronisation caused all nodes to
    align ‚Üí cut collapsed to near zero. No recovery mechanism existed.<br><br>
    <code>phase += dt * (W_coupling + field + noise)</code><br><br>
    The noise was constant. Temperature was fixed. When the system
    found a bad attractor it had no geometric drive to escape.
  </div>
  <div class="panel">
    <h3 style="color:var(--accent);margin-bottom:10px">WHAT DEERSKIN ADDS</h3>
    The <strong>Geometric Prior</strong> is a 2D cosine lattice.
    It monitors the eye orientation (derived from current spins) and
    exerts a <strong>gauge force</strong> ‚Äî twisting phases away from
    bad configurations. When stress spikes, <strong>viscous melt</strong>
    temporarily increases plasticity ‚Üí Prior reorients ‚Üí system escapes.<br><br>
    <code>stress = 1 ‚àí mean(Anchor √ó Eye) / 0.25</code><br><br>
    No temperature schedule. Plasticity is driven by <em>the problem itself</em>.
  </div>
</div>

<script>
// ============================================================
// Deerskin-PKAS  ‚Äî  JavaScript simulation engine
// ============================================================

const TAU = Math.PI * 2;

// ---------- State ----------
let N = 20, adj, pos, phases, W_mat, Ca, spins;
let bestCut = 0, bestSpins;
let priorTheta = 0, meltRate = 0.003;
let iteration = 0, rescues = 0, scarCount = 0;
let running = false, animId = null;
let cutHistory = [], stressHistory = [];

// Sliders
const slNodes  = document.getElementById('slNodes');
const slMelt   = document.getElementById('slMelt');
const slSpeed  = document.getElementById('slSpeed');

// ---- Graph generation (random 3-regular-ish) ----
function buildGraph(n) {
  const a = Array.from({length: n}, () => new Float32Array(n));
  // Circulant backbone: every node connects to ¬±1, ¬±2
  for (let i = 0; i < n; i++) {
    [1, 2, n-1, n-2].forEach(d => {
      const j = (i + d) % n;
      if (i !== j) { a[i][j] = 1; a[j][i] = 1; }
    });
  }
  // Random extra edges
  for (let k = 0; k < n; k++) {
    const i = Math.floor(Math.random() * n);
    const j = Math.floor(Math.random() * n);
    if (i !== j) { a[i][j] = 1; a[j][i] = 1; }
  }
  return a;
}

function countEdges(a) {
  let c = 0;
  for (let i = 0; i < a.length; i++)
    for (let j = i+1; j < a.length; j++)
      if (a[i][j]) c++;
  return c;
}

function initSolver() {
  N = parseInt(slNodes.value);
  adj = buildGraph(N);

  // Node positions on circle
  pos = Array.from({length: N}, (_, i) => ({
    x: 0.5 + 0.42 * Math.cos(TAU * i / N),
    y: 0.5 + 0.42 * Math.sin(TAU * i / N),
  }));

  phases = Float32Array.from({length: N}, () => Math.random() * TAU);
  W_mat  = Array.from({length: N}, (_, i) =>
    Float32Array.from({length: N}, (_, j) => (i===j?0:(Math.random()-0.5)*0.2)));
  Ca     = Array.from({length: N}, () => new Float32Array(N));
  spins  = new Int8Array(N).fill(1);

  priorTheta = 0; meltRate = parseFloat(slMelt.value) / 1000;
  iteration = 0; rescues = 0; scarCount = 0;
  bestCut = 0; bestSpins = new Int8Array(N).fill(1);
  cutHistory = []; stressHistory = [];

  log("New " + N + "-node graph initialised", "good");
  renderAll();
  updateStats();
}

// ---- Geometric Prior ----
function computeMoire(eyeTheta, size=40) {
  const freq = 2.0, data = [];
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      const x = (c/size)*2 - 1, y = (r/size)*2 - 1;
      const prx = x*Math.cos(priorTheta) - y*Math.sin(priorTheta);
      const pry = x*Math.sin(priorTheta) + y*Math.cos(priorTheta);
      const anchor = Math.cos(prx*freq*Math.PI) * Math.cos(pry*freq*Math.PI);
      const ex = x*Math.cos(eyeTheta) - y*Math.sin(eyeTheta);
      const ey = x*Math.sin(eyeTheta) + y*Math.cos(eyeTheta);
      const eye   = Math.cos(ex*freq*Math.PI) * Math.cos(ey*freq*Math.PI);
      data.push(anchor * eye);
    }
  }
  return data;
}

function stress(eyeTheta) {
  const field = computeMoire(eyeTheta, 20);
  const mean = field.reduce((s,v)=>s+v,0) / field.length;
  return Math.max(0, 1 - mean / 0.25);
}

function stressGradient(eyeTheta) {
  const eps = 0.02;
  return (stress(eyeTheta+eps) - stress(eyeTheta-eps)) / (2*eps);
}

// ---- Solver step ----
function solverStep() {
  const dt = 0.05;

  // Eye orientation from current spins
  const eyeTheta = spins.reduce((s,sp) => s + (sp===1?0:Math.PI/2), 0) / N;

  // Geometric stress
  const s = stress(eyeTheta);
  const gGrad = stressGradient(eyeTheta);

  // Viscous melt: prior rotates toward eye
  priorTheta += (eyeTheta - priorTheta) * meltRate;
  meltRate = Math.max(0.0005, meltRate * 0.9999);

  // Phase force per node
  for (let i = 0; i < N; i++) {
    let coupling = 0;
    for (let j = 0; j < N; j++) {
      if (adj[i][j]) coupling += W_mat[i][j] * Math.sin(phases[j] - phases[i]);
    }
    const geoForce = -0.5 * gGrad;
    const noise = (Math.random()-0.5) * (0.2 + 0.3 * nodeCa(i));
    phases[i] += dt * (coupling + geoForce + noise);
    phases[i] = ((phases[i] % TAU) + TAU) % TAU;
  }

  // Calcium update
  for (let i = 0; i < N; i++) {
    for (let j = i+1; j < N; j++) {
      if (adj[i][j]) {
        const coh = Math.cos(phases[i]-phases[j]) ** 2;
        Ca[i][j] = Math.min(1, (Ca[i][j] + coh*dt) * 0.95);
        Ca[j][i] = Ca[i][j];
      }
    }
  }

  // W update every 10 steps
  if (iteration % 10 === 0) {
    for (let i = 0; i < N; i++) {
      for (let j = i+1; j < N; j++) {
        if (adj[i][j] && Ca[i][j] > 0.3) {
          const delta = 0.001 * Ca[i][j];
          W_mat[i][j] += delta; W_mat[j][i] += delta;
        }
      }
    }
  }

  // Binarise
  for (let i = 0; i < N; i++)
    spins[i] = Math.cos(phases[i]) >= 0 ? 1 : -1;

  // Cut
  const cut = computeCut();
  if (cut > bestCut) { bestCut = cut; bestSpins = spins.slice(); }

  // Anti-collapse rescue
  if (cutHistory.length > 100) {
    const recent  = avg(cutHistory.slice(-50));
    const earlier = avg(cutHistory.slice(-100,-50));
    const nEdges  = countEdges(adj);
    if (earlier > 0 && (earlier - recent) / nEdges > 0.15) {
      meltRate = Math.min(0.05, meltRate * 5);
      rescues++;
      log(`Collapse detected @ iter ${iteration} ‚Äî rescue melt ${meltRate.toFixed(4)}`, "bad");
    }
  }

  cutHistory.push(cut);
  stressHistory.push(s);
  if (cutHistory.length > 2000) { cutHistory.shift(); stressHistory.shift(); }
  iteration++;
  if (iteration % 100 === 0) scarCount++;
}

function nodeCa(i) {
  let s = 0; for (let j = 0; j < N; j++) s += Ca[i][j]; return s/N;
}

function computeCut() {
  let c = 0;
  for (let i = 0; i < N; i++)
    for (let j = i+1; j < N; j++)
      if (adj[i][j] && spins[i] !== spins[j]) c++;
  return c;
}

function avg(arr) { return arr.length ? arr.reduce((s,v)=>s+v,0)/arr.length : 0; }

// ---- Renderers ----
function drawMoire() {
  const cv = document.getElementById('cvMoire');
  const ctx = cv.getContext('2d');
  const W = cv.width, H = cv.height, size = 40;
  const eyeTheta = spins.reduce((s,sp) => s + (sp===1?0:Math.PI/2), 0) / N;
  const data = computeMoire(eyeTheta, size);
  const bw = W/size, bh = H/size;
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      const v = data[r*size+c];
      const t = (v + 1) / 2;
      // Colour: dark = stress, teal = harmony
      const r2 = Math.round((1-t)*200 + t*0);
      const g2 = Math.round(t*255);
      const b2 = Math.round(t*221);
      ctx.fillStyle = `rgb(${r2},${g2},${b2})`;
      ctx.fillRect(c*bw, r*bh, bw+1, bh+1);
    }
  }
  // Draw Prior orientation line
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 2;
  const cx = W/2, cy = H/2, len = 40;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + len*Math.cos(priorTheta), cy + len*Math.sin(priorTheta));
  ctx.stroke();
}

function drawGraph() {
  const cv = document.getElementById('cvGraph');
  const ctx = cv.getContext('2d');
  const W = cv.width, H = cv.height;
  ctx.fillStyle = '#111122'; ctx.fillRect(0,0,W,H);

  const nEdges = countEdges(adj);
  const gx = i => pos[i].x * W, gy = i => pos[i].y * H;

  // Edges ‚Äî colour by calcium
  for (let i = 0; i < N; i++) {
    for (let j = i+1; j < N; j++) {
      if (!adj[i][j]) continue;
      const ca = Ca[i][j];
      const cut = spins[i] !== spins[j];
      const alpha = 0.3 + 0.5*ca;
      ctx.strokeStyle = cut ? `rgba(0,255,221,${alpha})` : `rgba(100,100,120,0.25)`;
      ctx.lineWidth = 1 + ca*2;
      ctx.beginPath(); ctx.moveTo(gx(i),gy(i)); ctx.lineTo(gx(j),gy(j)); ctx.stroke();
    }
  }

  // Nodes
  for (let i = 0; i < N; i++) {
    const ca = nodeCa(i);
    const r = 7 + ca*4;
    ctx.fillStyle = spins[i] === 1 ? '#ff6b6b' : '#4ecdc4';
    ctx.beginPath(); ctx.arc(gx(i),gy(i),r,0,TAU); ctx.fill();
    // Calcium glow
    if (ca > 0.3) {
      ctx.strokeStyle = `rgba(232,121,249,${ca})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }
}

function drawConvergence() {
  const cv = document.getElementById('cvConv');
  const ctx = cv.getContext('2d');
  const W = cv.width, H = cv.height;
  ctx.fillStyle = '#111122'; ctx.fillRect(0,0,W,H);

  const nEdges = countEdges(adj);
  if (cutHistory.length < 2) return;

  // Theoretical max line
  ctx.strokeStyle = 'rgba(255,107,107,0.4)'; ctx.lineWidth = 1; ctx.setLineDash([4,4]);
  const yMax = H * (1 - nEdges/nEdges * 0.85);
  ctx.beginPath(); ctx.moveTo(0,yMax); ctx.lineTo(W,yMax); ctx.stroke();
  ctx.setLineDash([]);

  const draw = (hist, color, maxVal) => {
    if (hist.length < 2) return;
    ctx.strokeStyle = color; ctx.lineWidth = 1.5;
    ctx.beginPath();
    hist.forEach((v, i) => {
      const x = (i/(hist.length-1))*W;
      const y = H * (1 - (v/maxVal)*0.85);
      i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
    });
    ctx.stroke();
  };

  draw(cutHistory,    '#00ffdd', nEdges);
  draw(stressHistory.map(s => s*nEdges), 'rgba(232,121,249,0.6)', nEdges);

  // Best cut label
  ctx.fillStyle = '#00ffdd'; ctx.font = '11px Consolas';
  ctx.fillText(`Best: ${bestCut}/${nEdges}  (${Math.round(100*bestCut/nEdges)}%)`, 8, 16);
}

function renderAll() { drawMoire(); drawGraph(); drawConvergence(); }

function updateStats() {
  const nEdges = countEdges(adj);
  const s = stressHistory.length ? stressHistory[stressHistory.length-1].toFixed(3) : '0.000';
  const cut = cutHistory.length ? cutHistory[cutHistory.length-1] : 0;
  const caMax = Ca.flat ? Math.max(...Ca.map(r=>[...r]).flat()).toFixed(3)
              : '0.000';

  document.getElementById('stStress').textContent = s;
  document.getElementById('stTheta').textContent  = priorTheta.toFixed(3);
  document.getElementById('stMelt').textContent   = meltRate.toFixed(5);
  document.getElementById('stScars').textContent  = scarCount;
  document.getElementById('stCut').textContent    = cut;
  document.getElementById('stBest').textContent   = bestCut;
  document.getElementById('stEdges').textContent  = nEdges;
  document.getElementById('stPct').textContent    = nEdges ? Math.round(100*bestCut/nEdges)+'%' : '0%';
  document.getElementById('stIter').textContent   = iteration;
  document.getElementById('stCa').textContent     = Math.max(...Ca.map(r=>Math.max(...r))).toFixed(3);
  document.getElementById('stRescues').textContent= rescues;
  document.getElementById('stStatus').textContent = running ? '‚ö° Running' : '‚è∏ Paused';
}

// ---- Main loop ----
function mainLoop() {
  const stepsPerFrame = parseInt(slSpeed.value);
  for (let i = 0; i < stepsPerFrame; i++) solverStep();
  renderAll();
  updateStats();
  if (running) animId = requestAnimationFrame(mainLoop);
}

// ---- Controls ----
document.getElementById('btnStart').addEventListener('click', () => {
  running = !running;
  document.getElementById('btnStart').textContent = running ? '‚è∏ Pause' : '‚ñ∂ Start';
  if (running) mainLoop();
});

document.getElementById('btnReset').addEventListener('click', () => {
  running = false;
  document.getElementById('btnStart').textContent = '‚ñ∂ Start';
  if (animId) cancelAnimationFrame(animId);
  initSolver();
});

document.getElementById('btnCollapse').addEventListener('click', () => {
  // Simulate the P-KAS phase collapse: sync all phases
  const syncPhase = Math.random() * TAU;
  phases.fill(syncPhase);
  log('üí• Phase collapse injected ‚Äî watching rescue mechanism‚Ä¶', 'bad');
});

slNodes.addEventListener('input', () => {
  document.getElementById('lblNodes').textContent = slNodes.value;
});
slMelt.addEventListener('input', () => {
  meltRate = parseFloat(slMelt.value) / 1000;
  document.getElementById('lblMelt').textContent = meltRate.toFixed(4);
});
slSpeed.addEventListener('input', () => {
  document.getElementById('lblSpeed').textContent = slSpeed.value;
});

function log(msg, cls='') {
  const box = document.getElementById('logBox');
  const line = document.createElement('div');
  if (cls) line.className = cls;
  line.textContent = `[${iteration}] ${msg}`;
  box.appendChild(line);
  box.scrollTop = box.scrollHeight;
  if (box.children.length > 30) box.removeChild(box.firstChild);
}

// Init on load
window.addEventListener('load', initSolver);
</script>
</body>
</html>
